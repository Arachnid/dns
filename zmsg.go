// *** DO NOT MODIFY ***
// AUTOGENERATED BY go generate from msg_generate.go

package dns

import (
	"encoding/base64"
	"net"
)

// pack*() functions
func (rr A) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(A)
	off, err = packDataA(rr.A, msg, off)
	if err != nil {
		return off, err
	}
	return l
}
func (rr AAAA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(AAAA)
	off, err = packDataAAAA(rr.AAAA, msg, off)
	if err != nil {
		return off, err
	}
	return l
}
func (rr AFSDB) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(AFSDB)
	l += 2 // Subtype
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(AFSDB)
	return l
}
func (rr ANY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	return l
}
func (rr CAA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CAA)
	l += 1 // Flag
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CAA)
	l += len(rr.Tag) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CAA)
	return l
}
func (rr CERT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CERT)
	l += 2 // Type
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CERT)
	l += 2 // KeyTag
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CERT)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CERT)
	return l
}
func (rr CNAME) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(CNAME)
	return l
}
func (rr DHCID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DHCID)
	return l
}
func (rr DNAME) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DNAME)
	return l
}
func (rr DNSKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DNSKEY)
	l += 2 // Flags
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DNSKEY)
	l += 1 // Protocol
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DNSKEY)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DNSKEY)
	return l
}
func (rr DS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DS)
	l += 2 // KeyTag
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DS)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DS)
	l += 1 // DigestType
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(DS)
	return l
}
func (rr EID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(EID)
	return l
}
func (rr EUI48) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(EUI48)
	return l
}
func (rr EUI64) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(EUI64)
	l += 8 // Address
	return l
}
func (rr GID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(GID)
	l += 4 // Gid
	return l
}
func (rr GPOS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(GPOS)
	l += len(rr.Longitude) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(GPOS)
	l += len(rr.Latitude) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(GPOS)
	l += len(rr.Altitude) + 1
	return l
}
func (rr HINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HINFO)
	l += len(rr.Cpu) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HINFO)
	l += len(rr.Os) + 1
	return l
}
func (rr HIP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	l += 1 // HitLength
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	l += 1 // PublicKeyAlgorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	l += 2 // PublicKeyLength
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(HIP)
	return l
}
func (rr IPSECKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	l += 1 // Precedence
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	l += 1 // GatewayType
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	off, err = packDataA(rr.GatewayA, msg, off)
	if err != nil {
		return off, err
	}
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	off, err = packDataAAAA(rr.GatewayAAAA, msg, off)
	if err != nil {
		return off, err
	}
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(IPSECKEY)
	return l
}
func (rr KX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(KX)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(KX)
	return l
}
func (rr L32) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(L32)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(L32)
	off, err = packDataA(rr.Locator32, msg, off)
	if err != nil {
		return off, err
	}
	return l
}
func (rr L64) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(L64)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(L64)
	l += 8 // Locator64
	return l
}
func (rr LOC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 1 // Version
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 1 // Size
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 1 // HorizPre
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 1 // VertPre
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 4 // Latitude
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 4 // Longitude
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LOC)
	l += 4 // Altitude
	return l
}
func (rr LP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LP)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(LP)
	return l
}
func (rr MB) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MB)
	return l
}
func (rr MD) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MD)
	return l
}
func (rr MF) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MF)
	return l
}
func (rr MG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MG)
	return l
}
func (rr MINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MINFO)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MINFO)
	return l
}
func (rr MR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MR)
	return l
}
func (rr MX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MX)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(MX)
	return l
}
func (rr NAPTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	l += 2 // Order
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	l += len(rr.Flags) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	l += len(rr.Service) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	l += len(rr.Regexp) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NAPTR)
	return l
}
func (rr NID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NID)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NID)
	l += 8 // NodeID
	return l
}
func (rr NIMLOC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NIMLOC)
	return l
}
func (rr NINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NINFO)
	return l
}
func (rr NS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NS)
	return l
}
func (rr NSAPPTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSAPPTR)
	return l
}
func (rr NSEC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC)
	return l
}
func (rr NSEC3) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	l += 1 // Hash
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	l += 1 // Flags
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	l += 2 // Iterations
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	l += 1 // SaltLength
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	l += 1 // HashLength
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3)
	return l
}
func (rr NSEC3PARAM) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3PARAM)
	l += 1 // Hash
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3PARAM)
	l += 1 // Flags
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3PARAM)
	l += 2 // Iterations
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3PARAM)
	l += 1 // SaltLength
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(NSEC3PARAM)
	return l
}
func (rr OPENPGPKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(OPENPGPKEY)
	return l
}
func (rr OPT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(OPT)
	return l
}
func (rr PTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(PTR)
	return l
}
func (rr PX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(PX)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(PX)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(PX)
	return l
}
func (rr RFC3597) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RFC3597)
	return l
}
func (rr RKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RKEY)
	l += 2 // Flags
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RKEY)
	l += 1 // Protocol
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RKEY)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RKEY)
	return l
}
func (rr RP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RP)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RP)
	return l
}
func (rr RRSIG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 2 // TypeCovered
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 1 // Labels
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 4 // OrigTtl
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 4 // Expiration
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 4 // Inception
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	l += 2 // KeyTag
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RRSIG)
	return l
}
func (rr RT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RT)
	l += 2 // Preference
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(RT)
	return l
}
func (rr SOA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	l += 4 // Serial
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	l += 4 // Refresh
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	l += 4 // Retry
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	l += 4 // Expire
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SOA)
	l += 4 // Minttl
	return l
}
func (rr SPF) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SPF)
	return l
}
func (rr SRV) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SRV)
	l += 2 // Priority
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SRV)
	l += 2 // Weight
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SRV)
	l += 2 // Port
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SRV)
	return l
}
func (rr SSHFP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SSHFP)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SSHFP)
	l += 1 // Type
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(SSHFP)
	return l
}
func (rr TA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TA)
	l += 2 // KeyTag
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TA)
	l += 1 // Algorithm
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TA)
	l += 1 // DigestType
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TA)
	return l
}
func (rr TALINK) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TALINK)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TALINK)
	return l
}
func (rr TKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 4 // Inception
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 4 // Expiration
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 2 // Mode
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 2 // Error
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 2 // KeySize
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += len(rr.Key) + 1
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += 2 // OtherLen
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TKEY)
	l += len(rr.OtherData) + 1
	return l
}
func (rr TLSA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TLSA)
	l += 1 // Usage
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TLSA)
	l += 1 // Selector
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TLSA)
	l += 1 // MatchingType
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TLSA)
	return l
}
func (rr TSIG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	l += 2 // Fudge
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	l += 2 // MACSize
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	l += 2 // OrigId
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	l += 2 // Error
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	l += 2 // OtherLen
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TSIG)
	return l
}
func (rr TXT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(TXT)
	return l
}
func (rr UID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(UID)
	l += 4 // Uid
	return l
}
func (rr UINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(UINFO)
	l += len(rr.Uinfo) + 1
	return l
}
func (rr URI) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(URI)
	l += 2 // Priority
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(URI)
	l += 2 // Weight
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(URI)
	return l
}
func (rr WKS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(WKS)
	off, err = packDataA(rr.Address, msg, off)
	if err != nil {
		return off, err
	}
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(WKS)
	l += 1 // Protocol
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(WKS)
	return l
}
func (rr X25) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
	off, err = packHeader(rr.Hdr, msg, off, compression, compress)
	if err != nil {
		return off, err
	}
	rr := new(X25)
	l += len(rr.PSDNAddress) + 1
	return l
}

// unpack*() functions
func (rr *A) copy() RR {
	return &A{*rr.Hdr.copyHeader(), copyIP(rr.A)}
}
func (rr *AAAA) copy() RR {
	return &AAAA{*rr.Hdr.copyHeader(), copyIP(rr.AAAA)}
}
func (rr *AFSDB) copy() RR {
	return &AFSDB{*rr.Hdr.copyHeader(), rr.Subtype, rr.Hostname}
}
func (rr *ANY) copy() RR {
	return &ANY{*rr.Hdr.copyHeader()}
}
func (rr *CAA) copy() RR {
	return &CAA{*rr.Hdr.copyHeader(), rr.Flag, rr.Tag, rr.Value}
}
func (rr *CERT) copy() RR {
	return &CERT{*rr.Hdr.copyHeader(), rr.Type, rr.KeyTag, rr.Algorithm, rr.Certificate}
}
func (rr *CNAME) copy() RR {
	return &CNAME{*rr.Hdr.copyHeader(), rr.Target}
}
func (rr *DHCID) copy() RR {
	return &DHCID{*rr.Hdr.copyHeader(), rr.Digest}
}
func (rr *DNAME) copy() RR {
	return &DNAME{*rr.Hdr.copyHeader(), rr.Target}
}
func (rr *DNSKEY) copy() RR {
	return &DNSKEY{*rr.Hdr.copyHeader(), rr.Flags, rr.Protocol, rr.Algorithm, rr.PublicKey}
}
func (rr *DS) copy() RR {
	return &DS{*rr.Hdr.copyHeader(), rr.KeyTag, rr.Algorithm, rr.DigestType, rr.Digest}
}
func (rr *EID) copy() RR {
	return &EID{*rr.Hdr.copyHeader(), rr.Endpoint}
}
func (rr *EUI48) copy() RR {
	return &EUI48{*rr.Hdr.copyHeader(), rr.Address}
}
func (rr *EUI64) copy() RR {
	return &EUI64{*rr.Hdr.copyHeader(), rr.Address}
}
func (rr *GID) copy() RR {
	return &GID{*rr.Hdr.copyHeader(), rr.Gid}
}
func (rr *GPOS) copy() RR {
	return &GPOS{*rr.Hdr.copyHeader(), rr.Longitude, rr.Latitude, rr.Altitude}
}
func (rr *HINFO) copy() RR {
	return &HINFO{*rr.Hdr.copyHeader(), rr.Cpu, rr.Os}
}
func (rr *HIP) copy() RR {
	RendezvousServers := make([]string, len(rr.RendezvousServers))
	copy(RendezvousServers, rr.RendezvousServers)
	return &HIP{*rr.Hdr.copyHeader(), rr.HitLength, rr.PublicKeyAlgorithm, rr.PublicKeyLength, rr.Hit, rr.PublicKey, RendezvousServers}
}
func (rr *IPSECKEY) copy() RR {
	return &IPSECKEY{*rr.Hdr.copyHeader(), rr.Precedence, rr.GatewayType, rr.Algorithm, copyIP(rr.GatewayA), copyIP(rr.GatewayAAAA), rr.GatewayName, rr.PublicKey}
}
func (rr *KX) copy() RR {
	return &KX{*rr.Hdr.copyHeader(), rr.Preference, rr.Exchanger}
}
func (rr *L32) copy() RR {
	return &L32{*rr.Hdr.copyHeader(), rr.Preference, copyIP(rr.Locator32)}
}
func (rr *L64) copy() RR {
	return &L64{*rr.Hdr.copyHeader(), rr.Preference, rr.Locator64}
}
func (rr *LOC) copy() RR {
	return &LOC{*rr.Hdr.copyHeader(), rr.Version, rr.Size, rr.HorizPre, rr.VertPre, rr.Latitude, rr.Longitude, rr.Altitude}
}
func (rr *LP) copy() RR {
	return &LP{*rr.Hdr.copyHeader(), rr.Preference, rr.Fqdn}
}
func (rr *MB) copy() RR {
	return &MB{*rr.Hdr.copyHeader(), rr.Mb}
}
func (rr *MD) copy() RR {
	return &MD{*rr.Hdr.copyHeader(), rr.Md}
}
func (rr *MF) copy() RR {
	return &MF{*rr.Hdr.copyHeader(), rr.Mf}
}
func (rr *MG) copy() RR {
	return &MG{*rr.Hdr.copyHeader(), rr.Mg}
}
func (rr *MINFO) copy() RR {
	return &MINFO{*rr.Hdr.copyHeader(), rr.Rmail, rr.Email}
}
func (rr *MR) copy() RR {
	return &MR{*rr.Hdr.copyHeader(), rr.Mr}
}
func (rr *MX) copy() RR {
	return &MX{*rr.Hdr.copyHeader(), rr.Preference, rr.Mx}
}
func (rr *NAPTR) copy() RR {
	return &NAPTR{*rr.Hdr.copyHeader(), rr.Order, rr.Preference, rr.Flags, rr.Service, rr.Regexp, rr.Replacement}
}
func (rr *NID) copy() RR {
	return &NID{*rr.Hdr.copyHeader(), rr.Preference, rr.NodeID}
}
func (rr *NIMLOC) copy() RR {
	return &NIMLOC{*rr.Hdr.copyHeader(), rr.Locator}
}
func (rr *NINFO) copy() RR {
	ZSData := make([]string, len(rr.ZSData))
	copy(ZSData, rr.ZSData)
	return &NINFO{*rr.Hdr.copyHeader(), ZSData}
}
func (rr *NS) copy() RR {
	return &NS{*rr.Hdr.copyHeader(), rr.Ns}
}
func (rr *NSAPPTR) copy() RR {
	return &NSAPPTR{*rr.Hdr.copyHeader(), rr.Ptr}
}
func (rr *NSEC) copy() RR {
	TypeBitMap := make([]uint16, len(rr.TypeBitMap))
	copy(TypeBitMap, rr.TypeBitMap)
	return &NSEC{*rr.Hdr.copyHeader(), rr.NextDomain, TypeBitMap}
}
func (rr *NSEC3) copy() RR {
	TypeBitMap := make([]uint16, len(rr.TypeBitMap))
	copy(TypeBitMap, rr.TypeBitMap)
	return &NSEC3{*rr.Hdr.copyHeader(), rr.Hash, rr.Flags, rr.Iterations, rr.SaltLength, rr.Salt, rr.HashLength, rr.NextDomain, TypeBitMap}
}
func (rr *NSEC3PARAM) copy() RR {
	return &NSEC3PARAM{*rr.Hdr.copyHeader(), rr.Hash, rr.Flags, rr.Iterations, rr.SaltLength, rr.Salt}
}
func (rr *OPENPGPKEY) copy() RR {
	return &OPENPGPKEY{*rr.Hdr.copyHeader(), rr.PublicKey}
}
func (rr *OPT) copy() RR {
	Option := make([]EDNS0, len(rr.Option))
	copy(Option, rr.Option)
	return &OPT{*rr.Hdr.copyHeader(), Option}
}
func (rr *PTR) copy() RR {
	return &PTR{*rr.Hdr.copyHeader(), rr.Ptr}
}
func (rr *PX) copy() RR {
	return &PX{*rr.Hdr.copyHeader(), rr.Preference, rr.Map822, rr.Mapx400}
}
func (rr *RFC3597) copy() RR {
	return &RFC3597{*rr.Hdr.copyHeader(), rr.Rdata}
}
func (rr *RKEY) copy() RR {
	return &RKEY{*rr.Hdr.copyHeader(), rr.Flags, rr.Protocol, rr.Algorithm, rr.PublicKey}
}
func (rr *RP) copy() RR {
	return &RP{*rr.Hdr.copyHeader(), rr.Mbox, rr.Txt}
}
func (rr *RRSIG) copy() RR {
	return &RRSIG{*rr.Hdr.copyHeader(), rr.TypeCovered, rr.Algorithm, rr.Labels, rr.OrigTtl, rr.Expiration, rr.Inception, rr.KeyTag, rr.SignerName, rr.Signature}
}
func (rr *RT) copy() RR {
	return &RT{*rr.Hdr.copyHeader(), rr.Preference, rr.Host}
}
func (rr *SOA) copy() RR {
	return &SOA{*rr.Hdr.copyHeader(), rr.Ns, rr.Mbox, rr.Serial, rr.Refresh, rr.Retry, rr.Expire, rr.Minttl}
}
func (rr *SPF) copy() RR {
	Txt := make([]string, len(rr.Txt))
	copy(Txt, rr.Txt)
	return &SPF{*rr.Hdr.copyHeader(), Txt}
}
func (rr *SRV) copy() RR {
	return &SRV{*rr.Hdr.copyHeader(), rr.Priority, rr.Weight, rr.Port, rr.Target}
}
func (rr *SSHFP) copy() RR {
	return &SSHFP{*rr.Hdr.copyHeader(), rr.Algorithm, rr.Type, rr.FingerPrint}
}
func (rr *TA) copy() RR {
	return &TA{*rr.Hdr.copyHeader(), rr.KeyTag, rr.Algorithm, rr.DigestType, rr.Digest}
}
func (rr *TALINK) copy() RR {
	return &TALINK{*rr.Hdr.copyHeader(), rr.PreviousName, rr.NextName}
}
func (rr *TKEY) copy() RR {
	return &TKEY{*rr.Hdr.copyHeader(), rr.Algorithm, rr.Inception, rr.Expiration, rr.Mode, rr.Error, rr.KeySize, rr.Key, rr.OtherLen, rr.OtherData}
}
func (rr *TLSA) copy() RR {
	return &TLSA{*rr.Hdr.copyHeader(), rr.Usage, rr.Selector, rr.MatchingType, rr.Certificate}
}
func (rr *TSIG) copy() RR {
	return &TSIG{*rr.Hdr.copyHeader(), rr.Algorithm, rr.TimeSigned, rr.Fudge, rr.MACSize, rr.MAC, rr.OrigId, rr.Error, rr.OtherLen, rr.OtherData}
}
func (rr *TXT) copy() RR {
	Txt := make([]string, len(rr.Txt))
	copy(Txt, rr.Txt)
	return &TXT{*rr.Hdr.copyHeader(), Txt}
}
func (rr *UID) copy() RR {
	return &UID{*rr.Hdr.copyHeader(), rr.Uid}
}
func (rr *UINFO) copy() RR {
	return &UINFO{*rr.Hdr.copyHeader(), rr.Uinfo}
}
func (rr *URI) copy() RR {
	return &URI{*rr.Hdr.copyHeader(), rr.Priority, rr.Weight, rr.Target}
}
func (rr *WKS) copy() RR {
	BitMap := make([]uint16, len(rr.BitMap))
	copy(BitMap, rr.BitMap)
	return &WKS{*rr.Hdr.copyHeader(), copyIP(rr.Address), rr.Protocol, BitMap}
}
func (rr *X25) copy() RR {
	return &X25{*rr.Hdr.copyHeader(), rr.PSDNAddress}
}
